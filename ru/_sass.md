
# О Sass

Вот так [Sass](http://sass-lang.com) описывает сам себя в своей [документации](http://sass-lang.com/documentation/file.SASS_REFERENCE.html):

> Sass — это расширение CSS, которое добавляет силу и элигантность к основному языку.

Основая цель Sass — исправить в CSS недостатки. CSS, как мы все знаем, не самый лучший язык в мире <sup>[указать источник]</sup>. Являясь довольно простым для освоения, он может быстро стать запутанным, особенно на больших проектах.

Вот в это время и вступает в свою роль Sass как язык мета-программирования, чтобы улучшить синтаксис CSS, чтобы обеспечить дополнительные возможности и удобные инструменты. Между тем, Sass остаётся консервативным в отношении языка CSS.

Цель в том, чтобы не превратить CSS в полнофункциональный язык программирования; Sass хочет лишь помочь – там, где не справляется CSS. Поэтому начать использовать Sass – не сложнее, чем начать изучать CSS. Он просто добавляет дополнительные возможности поверх CSS.

Есть много способов использовать эти возможности. Какие-то способы хороши, какие-то – не очень, а некоторые вообще необычные. Это руководство предназначено для того, чтобы дать последовательный и документированый подход для написания кода на Sass.

### Дальнейшее чтение

* [Sass](http://sass-lang.com)
* [Sass documentation](http://sass-lang.com/documentation/file.SASS_REFERENCE.html)

## Ruby Sass или LibSass

[Первый коммит в Sass](https://github.com/hcatlin/sass/commit/fa5048ba405619273e474a50400c7243fbff54fe) был сделан в конце 2006, более 8 лет назад. Излишне говорить, что Sass прошёл долгий путь с тех пор. Изначально разработанный на Ruby, он получил множество портов там и тут. Самый популяный – [LibSass](https://github.com/sass/libsass) (написан на Си), сейчас близок к полной совместимости с изначальным исполнением на Ruby.

В 2014 [команды Ruby Sass и LibSass решили подождать синхронизации версий, прежде чем двигаться дальше](https://github.com/sass/libsass/wiki/The-LibSass-Compatibility-Plan). С тех пор LibSass активно выпускает версии, догнать старшего брата. Последние оставшиеся несоответствия собраны и перечислены мной в проекте [Sass-Compatibility](http://sass-compatibility.github.io). Если вы знаете о несовместимости между этими двумя версиями, которой нет в списке, пожалуйста, создайте соответствующий Issue.

Вернёмся к выбору компилятора. На самом деле, всё зависит от вашего проекта. Если это Ruby on Rails, вам лучше использовать Ruby Sass, который идеально подходит для такого случая. Также следует помнить, что Ruby Sass — это всегда эталонная реализация и всегда будет обгонять LibSass.

Не на Ruby-проектах, которые нуждаются в интеграции рабочего процесса, LibSass, вероятно, лучшая идея, поскольку является наиболее популярным. Так что если вы хотите использовать, скажем, NodeJS, [node-sass](https://github.com/sass/node-sass) — ваш выбор.

### Дальнейшее чтение

* [LibSass](https://github.com/sass/libsass)
* [Sass-Compatibility](http://sass-compatibility.github.io)
* [Switching from Ruby Sass to LibSass](http://www.sitepoint.com/switching-ruby-sass-libsass/)

## Sass или SCSS

Существует довольно много путаницы относительно семантики имени *Sass*, и не зря: Sass означает как препроцессор, так и свой собственный синтаксис. Не очень удобно, не так ли?

Как видите, Sass первоначально описал синтаксис, определяющей характеристикой которого является его чувствительность к вложености. Вскоре в Sass решили сократить разрыв между Sass и CSS, обеспечивая дружественный для CSS синтаксис под названием *SCSS* или *Sassy CSS*. Девиз: “если это правильный CSS, то это правильный SCSS”.

С тех пор, Sass (препроцессор) предоставляет два различных синтаксиса: Sass (не все буквы заглавные, [пожалуйста](http://sassnotsass.com)), также известный как *синтаксис с отступом,* и SCSS. Какой из них использовать, в значительной степени, зависит от вас, так как оба строго равны по возможностям. Это только вопрос эстетики.

Cинтаксис Sass опирается на отступы, чтобы избавиться от скобок, точки с запятой и других символов пунктуации, что приводит к более компактному и более короткому синтаксису. Между тем, SCSS легче учиться, так как это в основном крошечные дополнительные кусочки на вершине CSS.

Лично я предпочитаю SCSS вместо Sass, потому что он близок к CSS и более дружелюбен для большинства разработчиков. Поэтому я буду использовать SCSS в этом руководстве.

### Дальнейшее чтение

* [What’s the difference between Sass and SCSS](http://www.sitepoint.com/whats-difference-sass-scss/)

## Другие препроцессоры

Sass — это препроцессор, коих много. Самый серьёзный соперник — это [LESS](http://lesscss.org/), основанный на NodeJS, который стал весьма популярен благодаря CSS-фреймворку [Bootstrap](http://getbootstrap.com/). Также есть [Stylus](http://learnboost.github.io/stylus/), который позволяет делать очень многое, так как почти превращает CSS в язык программирования.

*Почему выбирать Sass, а не другой препроцессор?* Это всё еще действующий вопрос сегодня. Не так давно мы рекомендовали использовать Sass для проектов на Ruby, потому что Sass был создан в Ruby и хорошо работает с Ruby On Rails. Теперь, когда LibSass догнал (в основном) оригинальный Sass, это уже не актуальный совет.

То, что мне нравится в Sass, так это его консервативный подход к CSS. Дизайн Sass основан на строгих принципах: большая часть проектного подхода приходит из мнений команды, о том что: а) добавление возможностей имеет стоимость в сложности, которая должна быть оправдана полезностью, и б) должно быть легко понятным, что делает определённый блок стилей, глядя только на него. Кроме того, Sass имеет гораздо более четкое внимание к деталям, чем другие препроцессоры. Насколько я могу судить, основные разработчики очень заботятся о поддержке совместимости с CSS, и любое общее поведение является последовательным.

Другими словами, Sass – не препроцессор, который направлен на удовлетворение гиковатых программистов, вроде меня, добавляя в язык возможности, которые не предназначены для поддержки любых логических сценариев использования. Это программное обеспечение, направленое на решение действительных вопросов; он помогает обеспечить полезные возможности CSS, где CSS не дотягивает.

Препроцессоры в сторону, мы должны также упомянуть постпроцессоры, которые получили значительное внимание в течение последних нескольких месяцев, главным образом благодаря [PostCSS](https://github.com/postcss/postcss) и [cssnext](HTTPS://cssnext.github.io/). Постпроцессоры во многом довольно похожи на препроцессоры, кроме того что они не обеспечивают ничего, кроме синтаксиса CSS.

Вы можете думать о постпроцессорах как о полифилах для неподдерживаемых возможностей CSS. Например, можно было бы написать переменные, как они описаны в [спецификации CSS](http://dev.w3.org/csswg/css-variables/), затем скомпилировать таблицы стилей с постпроцессором – только, чтобы найти каждую переменную и заменить на соотвествующее значение, как Sass и сделал бы.

Идея постпроцессоров в том, что как только браузеры поддерживают новые возможности (например, переменные CSS), постпроцессор больше не компилирует их, позволяя браузерам взять это на себя.

Предоставление синтаксиса завтрашнего дня является благородной идеей; я должен сказать, что я по-прежнему предпочитаю использовать Sass для большинства задач. Тем не менее, есть некоторые случаи, когда я считаю, что постпроцессоры подходят больше, чем Sass – например, для вендорных префиксов CSS – но мы к этому ещё вернёмся.

### Дальнейшее чтение

* [LESS](http://lesscss.org/)
* [Stylus](http://learnboost.github.io/stylus/)
* [cssnext](https://cssnext.github.io/)
* [PostCSS](https://github.com/postcss/postcss)
